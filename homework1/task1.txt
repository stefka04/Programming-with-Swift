import Foundation 

struct SemanticVersion {
  var major:Int
  var minor:Int
  var patch:Int
  var isPreRelease: Bool

  init(major: Int = 0, minor: Int = 0, patch:Int = 0, isPreRelease: Bool = false) {
    self.major = major
    self.minor = minor
    self.patch = patch
    self.isPreRelease = isPreRelease
  }

//TO-DO
  init() {
    self.init(major: 0, minor: 0, patch: 0, isPreRelease: false)
  }

  mutating func convertFromString(source:String) {
    var currentPart:String = ""
    var count: Int = 0

    for currentChar in source {
      if currentChar == "." {
        count += 1
        switch count {
          case 1: major = Int(currentPart)!
          case 2: minor = Int(currentPart)!
         // case 3: patch = Int(currentPart)! //nqma kak 3 .
          default: break
        }
        currentPart.removeAll()
      } else {
      currentPart.insert(currentChar, at:currentPart.endIndex)
      }

      //print("currentPart = \(currentPart)")
    }

    //za poslednata chast; ima 1 . (count = 1) 1.2
    switch count {
          case 0: major = Int(currentPart)!
          case 1: minor = Int(currentPart)!
          case 2: patch = Int(currentPart)!
          default: return
        }

    //print("major = \(major)    minor=\(minor)   patch=\(patch)")
  }

  func compareTo(other: SemanticVersion) -> Int {
    //!!! missing check for prerelease versions!!!
    /*if self.major > other.major {
      return 1
    } else if self.major < other.major {
      return -1
    } else {
        if self.major > other.major {
          return 1
        } else if self.major < other.major {
          return -1
          } else {
            return 0
          }
    }*/


    if _compareTо(first: self.major, second: other.major) == 0 {
      if _compareTо(first: self.minor, second: other.minor) == 0 {
        if _compareTо(first: self.patch, second: other.patch) == 0 {
          return _compareTо(first: self.isPreRelease, second: other.isPreRelease)
        } else {
           return _compareTо(first: self.patch, second: other.patch)
        }
      } else {
      return _compareTо(first: self.minor, second: other.minor)
    }
    } else {
      return _compareTо(first: self.major, second: other.major)
    }
  }

  func convertToString() -> String {
    return "\(self.major).\(self.minor).\(self.patch)"
  }

  private func _compareTо(first: Int, second: Int) -> Int {
    if first > second {
      return 1
    } else if first < second {
      return -1
    } else { 
      return 0
    }
  }

  private func _compareTо(first: Bool, second: Bool) -> Int {
    if !first && second {
      return 1
    } else if first && !second{
      return -1
    } else { 
      return 0
    }
  }
}

//TO-DO
func isPrereleaseVersion(version:String) -> Bool {
  return false
}

func isValidVersion(version:String) -> Bool {
   //print("isValid: " + version + "\n")
  if version.isEmpty {
    return false
  }

  var startWithZero: Bool = false
  var end: Bool = false
  var count: Int = 0   //broi tochki

  for currentChar in version {
    if currentChar == "0" && startWithZero == false && (end == true || count == 0) {
      startWithZero = true
      end = false  //????????????//
       
       //print("starts with 0 and current=: \(currentChar) \n")
    } else if count < 2 && currentChar != "." && startWithZero == true {
      //print("False starts with 0 and current=: \(currentChar) \n")
      return false
    } else if currentChar.isNumber {
      //print("number current=: \(currentChar) \n")
      continue
    } else if end == false && currentChar == "." {
      startWithZero = false
      end = true
      count += 1

      //print("end and current=: \(currentChar) \n")
      if count > 2 {
        print("count > 2 current=: \(currentChar) \n")
        return false
      }
    } else if count == 2 && (currentChar == "-" || currentChar == "+") {
      //print("prerelease and current=: \(currentChar) \n")
      return isPrereleaseVersion(version: version)
    } else {
      //print("False others and current=: \(currentChar) \n")
      return false
    }
  }
  
  /*if count != 2 {
    print("count != 2 count=: \(count) \n")
      return false
  }*/
  return true
}

func findMaxVersion(all: [String]) -> String? {
  
  /*var versions: [SemanticVersion] = []
  var index: Int = 0*/

  var maxVersion: SemanticVersion = SemanticVersion(major: -1, minor: -1, patch: -1)
  for versionStr in all {
    // print("input: " + versionStr + "\n")
    if isValidVersion(version: versionStr) {
     // print("valid version: " + versionStr + "\n")
      var currentVersion : SemanticVersion = SemanticVersion()
      currentVersion.convertFromString(source: versionStr)
      print("\(currentVersion.major).\(currentVersion.minor).\(currentVersion.patch)")

      if currentVersion.compareTo(other: maxVersion) == 1 {
        print("compare")
        maxVersion = currentVersion
        print("MAX : \(maxVersion.major).\(maxVersion.minor).\(maxVersion.patch)")
      }
    }
  }
    if maxVersion.major != -1 {
      return  maxVersion.convertToString()
    }
    return nil
}

//var result: String? = findMaxVersion(all: ["1.0.1"])
//var result: String? = findMaxVersion(all: ["1.0.1", "1.2", "1.0.2", "1.11"]) // "1.11"

//var result: String? = findMaxVersion(all: ["1", "3","1.0.2", "1.11"]) // "3"
//var result: String? = findMaxVersion(all: ["3", "1"]) // "3"

//nevalidni
//var result: String? = findMaxVersion(all: ["1.08.1", "001.8.1", "1.8.01", "1..1", ".."])
//var result: String? = findMaxVersion(all: ["1.8.01", "1..1", ".."])

//var result: String? = findMaxVersion(all: ["4."])  // not working TO-DO
//print("result: " + result)